import { Injectable } from '@angular/core';
import { WinCondition } from '../models/win-condition.type';
import { CookieService } from 'ngx-cookie-service';
import { ScoreTable } from '../models/score-table.type';

@Injectable({
  providedIn: 'root'
})
export class GameService {

  private score = 0;

  private scoreTable: ScoreTable = {
    'you win': 1,
    'you lose': -1,
    draw: 0
  };

  private winConditions: WinCondition = {
    rock: ['scissors'],
    paper: ['rock'],
    scissors: ['paper']
  }

  constructor(
    private cs: CookieService
  ) { }

  get getScore() {
    return this.score;
  }

  /**
   * Checks the local score stored in the cookie and sets it to this.score attribute.
   * If the score is not found in the cookie, it sets the score to 0.
   * 
   * @memberof GameService
   * @param {string} type - The type of score to check ('user' or 'cpu').
   * @returns {void}
   */
  checkLocalScore(scoreType: string): number {
    const localScore = parseInt(this.cs.get(scoreType) ?? '0');
    this.cs.set(scoreType, localScore.toString());
    return this.score += localScore;
  }

  /**
   * Asynchronously generates a move for the CPU player.
   * 
   * @async
   * @memberof GameService
   * @param {string[]} options - An array containing the available move options.
   * @returns {Promise<string>} A promise that resolves to a string representing the CPU's move.
   */
  async cpuMove(options: string[]): Promise<string> {
    await this.delay(500);
    const randomNumber = Math.trunc(Math.random() * options.length);
    return options[randomNumber];
  }

  /**
   * Stores the user's move selection in a cookie.
   * 
   * @memberof GameService
   * @param userMove - The user's move selection
   * @returns {void}
   */
  play(userMove: string): void {
    this.cs.set('userMove', userMove);
  }

  /**
   * Updates the score and returns the result of the game.
   * @memberof GameService
   * @param userMove - The move chosen by the user.
   * @param cpuMove - The move generated by the CPU.
   * @param scoreType - The type of score to update.
   * @returns A string with the result of the game ('draw', 'you win', 'you lose').
   */
  setGame(userMove: string, cpuMove: string, scoreType: string) {
    const result = this.calculateResult(userMove, cpuMove);
    this.updateScore(result, scoreType);
    return result;
  }

  /**
   * Updates the score according to the result of the game and the specified score type.
   * @memberof GameService
   * @param result - The result of the game ('you win', 'you lose', or 'draw').
   * @param scoreType - The type of score to update ('localScore' or 'globalScore').
   * @returns void
   */
  updateScore(result: string, scoreType: string) {
    //Gets the current score from the cookie.
    const currentScore = parseInt(this.cs.get(scoreType) ?? '0');

    //Calculates the new score and updates the score attribute.
    const newScore = this.calculateNewScore(result, currentScore);
    this.score = newScore;
    this.cs.set(scoreType, newScore.toString());
  };

  /**
   * Calculates the result of the game based on the user move, the cpu move and the score type.
   * @private
   * @memberof GameService
   * @param userMove - The user's move, as a string.
   * @param cpuMove - The CPU's move, as a string.
   * @returns A string representing the result of the game, either 'you win', 'you lose' or 'draw'.
   */
  private calculateResult(userMove: string, cpuMove: string) {
    if (userMove === cpuMove) return 'draw';
    const userWins = this.winConditions[userMove].includes(cpuMove);
    return userWins ? 'you win' : 'you lose';
  }

  /**
   * Calculates the new score based on the game result and the current score.
   * 
   * @private
   * @memberof GameService
   * @param currentScore - The current score of the player.
   * @param result - The game result, can be "you win", "you lose" or "draw".
   * @returns The new score of the player after the game.
   */
  private calculateNewScore(result: string, currentScore: number): number {
    const scoreChange = this.scoreTable[result] ?? 0;
    return currentScore + scoreChange;
  };

  /**
   * Delays the execution of code for a specified amount of time.
   * 
   * @async 
   * @memberOf GameService 
   * @param ms - The time to delay in millisecons.
   * @returns A promise that resolves after the specified time has elapsed.
   * @returns {Promise<void>}
   */
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
